-- Создание таблиц 
CREATE TABLE Students (
    student_id SERIAL PRIMARY KEY, 
    full_name VARCHAR(255) NOT NULL, 
    email VARCHAR(255) UNIQUE NOT NULL, 
    start_year INT -- Год поступления студента
);

CREATE TABLE Courses (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(255) NOT NULL,
    credits INT CHECK (credits > 0) -
);

CREATE TABLE Enrollments (
    student_id INT REFERENCES Students(student_id) ON DELETE CASCADE, 
    course_id INT REFERENCES Courses(course_id) ON DELETE CASCADE,
    grade CHAR(1), 
    PRIMARY KEY (student_id, course_id)
);

-- Задание 1: INSERT

-- 1.1 Добавление студентов
INSERT INTO Students (full_name, email, start_year) VALUES
('Алексей Смирнов', 'alexey.smirnov@example.com', 2021),
('Елена Кузнецова', 'elena.kuznetsova@example.com', 2022),
('Дмитрий Новиков', 'dmitry.novikov@example.com', 2021),
('Ольга Морозова', 'olga.morozova@example.com', 2023);

-- 1.2 Добавление курсов
INSERT INTO Courses (course_name, credits) VALUES
('Введение в программирование', 5),
('Базы данных', 4),
('Веб-технологии', 4);

-- 1.3 Запись студентов на курсы
INSERT INTO Enrollments (student_id, course_id, grade) VALUES (1, 2, 'A');

INSERT INTO Enrollments (student_id, course_id, grade) VALUES (2, 2, 'B');

INSERT INTO Enrollments (student_id, course_id, grade) VALUES (2, 3, 'A');

INSERT INTO Enrollments (student_id, course_id) VALUES (3, 1);
INSERT INTO Enrollments (student_id, course_id) VALUES (3, 2);
INSERT INTO Enrollments (student_id, course_id) VALUES (3, 3);

-- Задание 2: UPDATE

-- 2.1 Изменение email Елены Кузнецовой
UPDATE Students SET email = 'elena.kuznetsova@newmail.com' WHERE student_id = 2;

-- 2.2 Проставление оценки Дмитрию Новикову за 'Введение в программирование' (course_id=1)
UPDATE Enrollments SET grade = 'A' WHERE student_id = 3 AND course_id = 1;

-- Задание 3: Удаление данных (DELETE)

DELETE FROM Students WHERE student_id = 4;

Задание 1: Заказы и их владельцы (INNER JOIN)
Ваш код: Правильный. INNER JOIN корректно соединяет таблицы по customer_id, выводя только заказы с существующими покупателями.
Результат: Список заказов с именами и датами.
Задание 2: Покупатели без заказов (LEFT JOIN)
Ваш код: Правильный. LEFT JOIN включает всех покупателей, а WHERE Orders.order_id IS NULL фильтрует тех, у кого нет заказов.
Результат: Только имена покупателей без заказов (например, Андрей Николаев).
Задание 3: Состав конкретного заказа (Multi-JOIN)
Ваш код: Правильный. Множественные INNER JOIN корректно связывают таблицы для получения данных по order_id = 1.
Результат: Названия товаров, количества и цены для заказа 1.
Задание 4: Покупатели определенного товара (Подзапрос с IN)
Ваш код: Правильный. Подзапрос находит customer_id тех, кто заказывал 'Смартфон', а основной запрос фильтрует по ним.
Результат: Имена покупателей (Иван Иванов, Алексей Смирнов).
Задание 5: Дорогие товары (Скалярный подзапрос)
Ваш код: Правильный. Скалярный подзапрос вычисляет среднюю цену, и фильтр отбирает товары выше неё.
Результат: Названия и цены товаров дороже среднего (например, Смартфон и Ноутбук, если средняя ~40k).
Задание 6: Заказы с дорогими товарами (Коррелирующий подзапрос c EXISTS)
Ваш код: Правильный. EXISTS проверяет наличие товаров >100000 в каждом заказе (корреляция по order_id).
Результат: Заказы с такими товарами (например, заказ 2 с Ноутбуком).
Задание 7: Сравнение подходов
Ваш код (оба варианта): Правильный.
NOT IN: Фильтрует покупателей, чьи customer_id не в списке заказчиков 'Ноутбука'.
LEFT JOIN с подзапросом: Соединяет с уникальными заказчиками 'Ноутбука' и фильтрует по IS NULL.
Результат: Покупатели, не заказывавшие 'Ноутбук' (все, кроме Марии Петровой).
Замечание: Оба подхода эквивалентны, но LEFT JOIN может быть эффективнее на больших данных (избегайте NOT IN с NULL, если есть риски).
Задание 8: Товары, которые еще никто не заказывал (RIGHT JOIN или LEFT JOIN с IS NULL)
Ваш код: Правильный. LEFT JOIN с IS NULL находит товары без заказов.
Результат: Названия товаров без заказов (например, Книга, Пылесос, если они не заказаны).
Замечание: RIGHT JOIN тоже подошёл бы (симметрично), но ваш вариант корректен.
Задание 9: Полный список активности (FULL OUTER JOIN)
Ваш код: В целом правильный. FULL OUTER JOIN включает всех покупателей, заказы и товары с NULL для отсутствующих связей.
Результат: Список с именами покупателей, товарами и количествами, включая NULL (например, покупатели без заказов и товары без заказов).
Замечание: Логика соответствует заданию, но запрос соединяет через заказы, так что это не "все возможные комбинации" (как в CROSS JOIN), а только связанные данные с NULL. Если нужно именно полное пересечение, добавьте CROSS JOIN, но по заданию ваш вариант подходит.
Задание 10: Покупатели, купившие самый дорогой товар
Ваш код (оба варианта): Правильный.
JOIN с подзапросом: Соединяет таблицы и фильтрует по максимальной цене.
Только подзапросы: Вложенные IN находят цепочку от товара к покупателю.
Результат: Имена покупателей, купивших самый дорогой товар (Ноутбук за 120k — Мария Петрова).
Замечание: DISTINCT в первом варианте убирает дубли, если один покупатель купил несколько раз.
Задание 11: Все возможные пары "покупатель-категория" (CROSS JOIN)
Ваш код: Неправильный. Таблицы Categories нет в схеме — это опечатка. Категории хранятся в Products.category.
Исправленный код: Чтобы вывести уникальные комбинации (без дубликатов товаров в категориях), используйте:

Copy code
SELECT DISTINCT Customers.full_name, Products.category
FROM Customers
CROSS JOIN Products;
Или, если хотите только уникальные категории:

Copy code
SELECT Customers.full_name, Cat.category
FROM Customers
CROSS JOIN (SELECT DISTINCT category FROM Products) AS Cat;
Результат: Все комбинации имён и категорий (например, Иван Иванов + Электроника и т.д.).
Задание 12: Кто кого порекомендовал (SELF JOIN)
Ваш код: Правильный. SELF JOIN с алиасами корректно связывает покупателей с рекомендаторами.
Результат: Список новых покупателей и их рекомендаторов (с NULL для тех, кого никто не рекомендовал).
